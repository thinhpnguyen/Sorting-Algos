{"version":3,"sources":["components/Graph.js","components/Header.js","components/Input.js","utilities/Sort.js","components/App.js","index.js"],"names":["ChartWrapper","canvasId","data","title","height","backgroundColorArray","Array","length","fill","ctx","document","getElementById","getContext","this","flag","chart_ctx","Chart","type","labels","map","v","datasets","label","backgroundColor","borderColor","borderWidth","options","scales","y","max","beginAtZero","responsive","animation","duration","plugins","legend","display","tooltip","enabled","text","font","size","update","newData","updateData","val","i","a","b","arr","tmp","Graph","id","sortType","sort","reset","nums","sortFunction","useState","undefined","graph_wrapper","setGraph","useEffect","updateChart","console","log","setFlag","className","width","header","onClick","window","location","href","input","props","placeholder","onChange","handleChange","value","onKeyDown","handleEnter","autoFocus","handleClear","delay","sleep","milliseconds","Promise","resolve","setTimeout","BubbleSort","inputArr","getChartData","n","j","getFlag","highlight","swap","unhighlight","SelectionSort","min","exMin","highlightMin","MergeSort","merge","l","m","r","n1","n2","L","R","k","mergeSortHelper","Math","floor","QuickSort","partition","low","high","pivot","quickSortHelper","pi","InsertionSort","key","ShellSort","gap","temp","App","sortEn","updateSortEn","updateReset","updateInput","filteredInput","useMemo","replace","split","filtered","forEach","str","push","parseInt","inputToNums","num","findMax","Header","Input","event","newInput","target","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.1b172720.chunk.js","sourcesContent":["import React, { useEffect, useState } from \"react\";\nimport Chart from \"chart.js/auto\";\n\n/*\nThis class is an adapter which takes care of creating or updating the graph.js object\nIt also adds more functionality such as highlighting\n*/\nclass ChartWrapper {\n  constructor(canvasId, data, title, height) {\n    let backgroundColorArray = new Array(data.length);\n    backgroundColorArray.fill(\"rgba(255, 99, 132, 0.2)\");\n    let ctx = document.getElementById(canvasId).getContext(\"2d\");\n\n    /* \n    This flag this used to stop the async sort functions to operate on the new data when reset\n    Because the update methods will operate on new data array ref\n    We can move the update the methods to the Sort module instead, as a second choice, so they will only update on the old data set\n    Which the user will not see, \n     */\n    this.flag = false;\n\n    this.chart_ctx = new Chart(ctx, {\n      type: \"bar\",\n      data: {\n        labels: data.map((v) => \"\"),\n        datasets: [\n          {\n            label: title,\n            data: data,\n            backgroundColor: [...backgroundColorArray],\n            borderColor: \"rgba(255, 99, 132, 1)\",\n            borderWidth: 1,\n          },\n        ],\n      },\n      options: {\n        scales: {\n          y: {\n            max: height,\n            beginAtZero: true,\n          },\n        },\n        responsive: false,\n        animation: {\n          duration: 0,\n        },\n        plugins: {\n          legend: {\n            display: false,\n          },\n          tooltip: {\n            enabled: false,\n          },\n          title: {\n            display: true,\n            text: title,\n            font: {\n              size: 20,\n            },\n          },\n        },\n      },\n    });\n  }\n\n  updateData() {\n    this.chart_ctx.update();\n  }\n  updateChart(newData, max) {\n    this.flag = false;\n    this.chart_ctx.data.datasets[0].data = newData;\n    this.chart_ctx.data.labels = newData.map((v) => \"\");\n    let backgroundColorArray = new Array(newData.length);\n    backgroundColorArray.fill(\"rgba(255, 99, 132, 0.2)\");\n    this.chart_ctx.data.datasets[0].backgroundColor = [...backgroundColorArray];\n    this.chart_ctx.options.scales.y.max = max;\n    this.updateData();\n  }\n  getChartCtx() {\n    return this.chart_ctx;\n  }\n  getChartData() {\n    return this.chart_ctx.data.datasets[0].data;\n  }\n  getChartLabels() {\n    return this.chart_ctx.labels;\n  }\n  getFlag() {\n    return this.flag;\n  }\n\n  /** Update Methods **/\n\n  setFlag(val) {\n    this.flag = val;\n  }\n  updateAnElement(i, val) {\n    if (!this.flag) return;\n    this.chart_ctx.data.datasets[0].data[i] = val;\n  }\n\n  highlight(i) {\n    if (!this.flag) return;\n    this.chart_ctx.data.datasets[0].backgroundColor[i] =\n      \"rgba(255, 99, 132, 0.8)\";\n    this.updateData();\n  }\n\n  unhighlight(i) {\n    if (!this.flag) return;\n    this.chart_ctx.data.datasets[0].backgroundColor[i] =\n      \"rgba(255, 99, 132, 0.2)\";\n    this.updateData();\n  }\n\n  highlightMin(i) {\n    if (!this.flag) return;\n    this.chart_ctx.data.datasets[0].backgroundColor[i] =\n      \"rgba(54, 162, 235, 0.2)\";\n    this.updateData();\n  }\n\n  swap(a, b) {\n    if (!this.flag) return;\n    let arr = this.chart_ctx.data.datasets[0].data;\n\n    let tmp = arr[a];\n    arr[a] = arr[b];\n    arr[b] = tmp;\n\n    this.updateData();\n  }\n}\n\nlet Graph = ({ id, sortType, sort, reset, nums, max, sortFunction }) => {\n  // props.reset in initialized to true to render the empty graph first\n  let [graph_wrapper, setGraph] = useState(undefined);\n\n  useEffect(() => {\n    if (!reset) return;\n    if (graph_wrapper === undefined) {\n      setGraph(new ChartWrapper(id, [...nums], sortType, max));\n    } else {\n      graph_wrapper.updateChart([...nums], max);\n    }\n  }, [graph_wrapper, id, max, nums, sortType, reset]);\n\n  useEffect(() => {\n    console.log(graph_wrapper);\n    graph_wrapper && graph_wrapper.setFlag(sort);\n    if (sort) {\n      sortFunction(graph_wrapper);\n    }\n  }, [sortFunction, graph_wrapper, sort]);\n  return <canvas className=\"graph\" id={id} width=\"400\" height=\"400\"></canvas>;\n};\nexport default Graph;\n","import React from \"react\";\n\nfunction header() {\n  return (\n    <div className=\"navbar\">\n      <div\n        className=\"logo\"\n        onClick={() => {\n          window.location.href = \"/\";\n        }}\n      >\n        Flow\n      </div>\n    </div>\n  );\n}\n\nexport default header;\n","import React from \"react\";\n\nfunction input(props) {\n  return (\n    <div className=\"inputField\">\n      <input\n        placeholder=\"Type in a list of numbers. Ex: 3 5 7 9\"\n        onChange={props.handleChange}\n        className=\"input\"\n        value={props.input}\n        onKeyDown={props.handleEnter}\n        autoFocus\n      />\n      <div>\n        <i className=\"fas fa-times clearButton\" onClick={props.handleClear}></i>\n      </div>\n    </div>\n  );\n}\n\nexport default input;\n","let delay = 10;\n\nconst sleep = (milliseconds) => {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n};\n\nexport async function BubbleSort(ChartWrapper) {\n  let inputArr = ChartWrapper.getChartData();\n  //let labels = myChart.data.labels;\n  let n = inputArr.length;\n\n  let i, j;\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < n - i; j++) {\n      if (!ChartWrapper.getFlag()) return;\n      ChartWrapper.highlight(j);\n      if (inputArr[j] > inputArr[j + 1]) {\n        ChartWrapper.highlight(j + 1);\n        ChartWrapper.swap(j, j + 1);\n      }\n      await sleep(delay);\n      ChartWrapper.unhighlight(j + 1);\n      ChartWrapper.unhighlight(j);\n    }\n  }\n}\n\nexport async function SelectionSort(ChartWrapper) {\n  let inputArr = ChartWrapper.getChartData();\n  let n = inputArr.length;\n  for (let i = 0; i < n; i++) {\n    //change color if ith column\n    ChartWrapper.highlight(i);\n\n    // Finding the smallest number in the subarray\n    let min = i;\n    let exMin = i;\n    for (let j = i + 1; j < n; j++) {\n      if (!ChartWrapper.getFlag()) return;\n      //first hightlight the pointer\n      ChartWrapper.highlight(j);\n      if (inputArr[j] < inputArr[min]) {\n        exMin = min;\n        min = j;\n      }\n      await sleep(delay);\n      ChartWrapper.unhighlight(j);\n\n      //change the hightlight if min changes\n      if (min !== exMin) {\n        if (exMin !== i) {\n          ChartWrapper.unhighlight(exMin);\n        }\n        ChartWrapper.highlightMin(min);\n      }\n    }\n    if (min !== i) {\n      ChartWrapper.unhighlight(min);\n      // Swapping the elements and labels\n      ChartWrapper.swap(min, i);\n    }\n\n    //change color back\n    ChartWrapper.unhighlight(i);\n  }\n}\n\nexport function MergeSort(ChartWrapper) {\n  const merge = async (arr, l, m, r) => {\n    ChartWrapper.highlight(l);\n    ChartWrapper.highlight(r);\n    if (!ChartWrapper.getFlag()) return;\n    let n1 = m - l + 1;\n    let n2 = r - m;\n\n    // Create temp arrays\n    let L = new Array(n1);\n    let R = new Array(n2);\n\n    // Copy data to temp arrays L[] and R[]\n    for (let i = 0; i < n1; i++) L[i] = arr[l + i];\n    for (let j = 0; j < n2; j++) R[j] = arr[m + 1 + j];\n\n    // Merge the temp arrays back into arr[l..r]\n\n    // Initial index of first subarray\n    let i = 0;\n\n    // Initial index of second subarray\n    let j = 0;\n\n    // Initial index of merged subarray\n    let k = l;\n\n    while (i < n1 && j < n2) {\n      if (!ChartWrapper.getFlag()) return;\n      if (L[i] <= R[j]) {\n        arr[k] = L[i];\n        i++;\n      } else {\n        arr[k] = R[j];\n        j++;\n      }\n      k++;\n      ChartWrapper.updateData();\n      await sleep(delay);\n    }\n\n    // Copy the remaining elements of\n    // L[], if there are any\n    while (i < n1) {\n      if (!ChartWrapper.getFlag()) return;\n      arr[k] = L[i];\n      i++;\n      k++;\n      ChartWrapper.updateData();\n      await sleep(delay);\n    }\n\n    // Copy the remaining elements of\n    // R[], if there are any\n    while (j < n2) {\n      if (!ChartWrapper.getFlag()) return;\n      arr[k] = R[j];\n      j++;\n      k++;\n      ChartWrapper.updateData();\n      await sleep(delay);\n    }\n\n    ChartWrapper.unhighlight(l);\n    ChartWrapper.unhighlight(r);\n  };\n  const mergeSortHelper = async (arr, l, r) => {\n    if (!ChartWrapper.getFlag()) return;\n\n    if (l >= r) {\n      return; //returns recursively\n    }\n    let m = l + Math.floor((r - l) / 2);\n    await mergeSortHelper(arr, l, m);\n    await mergeSortHelper(arr, m + 1, r);\n    await merge(arr, l, m, r);\n  };\n  (function () {\n    let inputArr = ChartWrapper.getChartData();\n    let n = inputArr.length;\n    mergeSortHelper(inputArr, 0, n - 1);\n  })();\n}\n\nexport function QuickSort(ChartWrapper) {\n  async function partition(arr, low, high) {\n    if (!ChartWrapper.getFlag()) return;\n    // pivot\n    let pivot = arr[high];\n    ChartWrapper.highlight(high);\n    ChartWrapper.highlight(low);\n    // Index of smaller element and\n    // indicates the right position\n    // of pivot found so far\n    let i = low - 1;\n\n    for (let j = low; j <= high - 1; j++) {\n      if (!ChartWrapper.getFlag()) return;\n      // If current element is smaller\n      // than the pivot\n      if (arr[j] < pivot) {\n        // Increment index of\n        // smaller element\n        ++i;\n        ChartWrapper.swap(i, j);\n      }\n      await sleep(delay);\n    }\n    //await sleep(delay);\n    ChartWrapper.swap(i + 1, high);\n    ChartWrapper.unhighlight(high);\n    ChartWrapper.unhighlight(low);\n    return i + 1;\n  }\n  async function quickSortHelper(arr, low, high) {\n    if (!ChartWrapper.getFlag()) return;\n    if (low < high) {\n      // pi is partitioning index, arr[p]\n      // is now at right place\n      let pi = await partition(arr, low, high);\n\n      // Separately sort elements before\n      // partition and after partition\n      await quickSortHelper(arr, low, pi - 1);\n      await quickSortHelper(arr, pi + 1, high);\n    }\n  }\n  (function quickSort() {\n    let inputArr = ChartWrapper.getChartData();\n    let n = inputArr.length;\n    quickSortHelper(inputArr, 0, n - 1);\n  })();\n}\n\nexport async function InsertionSort(ChartWrapper) {\n  let arr = ChartWrapper.getChartData();\n  let n = arr.length;\n  let i, key, j;\n  for (i = 1; i < n; i++) {\n    if (!ChartWrapper.getFlag()) return;\n\n    key = arr[i];\n    j = i - 1;\n\n    /* Move elements of arr[0..i-1], that are  \n        greater than key, to one position ahead  \n        of their current position */\n    while (j >= 0 && arr[j] > key) {\n      if (!ChartWrapper.getFlag()) return;\n      ChartWrapper.highlight(j);\n      ChartWrapper.highlight(j + 1);\n      arr[j + 1] = arr[j];\n      ChartWrapper.updateData();\n      await sleep(delay);\n      ChartWrapper.unhighlight(j);\n      ChartWrapper.unhighlight(j + 1);\n      j = j - 1;\n    }\n    arr[j + 1] = key;\n    ChartWrapper.updateData();\n    await sleep(delay);\n  }\n}\n\nexport async function ShellSort(ChartWrapper) {\n  let arr = ChartWrapper.getChartData();\n  let n = arr.length;\n\n  // Start with a big gap, then reduce the gap\n  for (let gap = Math.floor(n / 2); gap > 0; gap = Math.floor(gap / 2)) {\n    if (!ChartWrapper.getFlag()) return;\n    // Do a gapped insertion sort for this gap size.\n    // The first gap elements a[0..gap-1] are already\n    // in gapped order keep adding one more element\n    // until the entire array is gap sorted\n    for (let i = gap; i < n; i += 1) {\n      if (!ChartWrapper.getFlag()) return;\n      // add a[i] to the elements that have been gap\n      // sorted save a[i] in temp and make a hole at\n      // position i\n      let temp = arr[i];\n\n      // shift earlier gap-sorted elements up until\n      // the correct location for a[i] is found\n      let j;\n      //highlight in case doesn't enter the for loop\n      ChartWrapper.highlight(i);\n      ChartWrapper.highlight(i - gap);\n      for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {\n        if (!ChartWrapper.getFlag()) return;\n        ChartWrapper.highlight(j);\n        ChartWrapper.highlight(j - gap);\n        arr[j] = arr[j - gap];\n        ChartWrapper.updateData();\n        await sleep(delay);\n        ChartWrapper.unhighlight(j);\n        ChartWrapper.unhighlight(j - gap);\n      }\n      await sleep(delay);\n      ChartWrapper.unhighlight(i);\n      ChartWrapper.unhighlight(i - gap);\n      // put temp (the original a[i]) in its correct\n      // location\n      arr[j] = temp;\n      ChartWrapper.updateData();\n    }\n  }\n}\n","import React, { useState, useMemo } from \"react\";\nimport Graph from \"./Graph.js\";\nimport Header from \"./Header.js\";\nimport Input from \"./Input.js\";\nimport {\n  BubbleSort,\n  SelectionSort,\n  MergeSort,\n  QuickSort,\n  InsertionSort,\n  ShellSort,\n} from \"../utilities/Sort.js\";\n\n//this function takes in a string\n//filter out only the number part\nfunction filter(str) {\n  // only takes str the first 20 numbers, exlude other characters\n  str = str.replace(/[^\\d\\s]/g, \"\");\n  str = str.replace(/\\s\\s+/g, \" \");\n  str = str.replace(/(^\\s|\\s$)/g, \"\");\n  //console.log(str);\n  return str.split(\" \", 100);\n}\nfunction inputToNums(filtered) {\n  let nums = [];\n  filtered.forEach((str) => {\n    nums.push(parseInt(str, 10));\n  });\n  return nums;\n}\n\nfunction findMax(nums) {\n  let m = 1; // default value for y-axis\n  nums.forEach((num) => {\n    if (num > m) m = num;\n  });\n  return m;\n}\n\nfunction App() {\n  const [sortEn, updateSortEn] = useState(false);\n  const [reset, updateReset] = useState(true); // render empty graph first\n  //input\n  const [input, updateInput] = useState(\n    \"9 8 7 6 5 4 3 2 3 4 5 6 7 6 5 4 3 2 3 4 5 6 7 8 9\"\n  );\n\n  const filteredInput = useMemo(() => filter(input), [input]); // use for labels\n  const nums = useMemo(() => inputToNums(filteredInput), [filteredInput]);\n  const max = useMemo(() => findMax(nums), [nums]); // use to scale the graph, so it will be changed during sorting\n\n  //////////////// State Handles /////////////////////////\n  function handleSort() {\n    updateReset(false);\n    updateSortEn(true);\n  }\n\n  function handleReset() {\n    //console.log(nums);\n    updateReset(true);\n    updateSortEn(false);\n  }\n\n  function handleEnter(event) {\n    if (event.key !== \"Enter\") return;\n    updateReset(true);\n    updateSortEn(false);\n    //console.log(\"enter\");\n  }\n  function handleChange(event) {\n    const newInput = event.target.value;\n    updateInput(newInput);\n    updateReset(false); //allow the reset button to work again\n  }\n\n  function handleClear() {\n    updateReset(false);\n    updateInput(\"\");\n  }\n\n  return (\n    <div>\n      <Header />\n      <div className=\"controlArea\">\n        <Input\n          handleChange={handleChange}\n          handleClear={handleClear}\n          handleEnter={handleEnter}\n          input={input}\n        />\n        <div className=\"globalButton\">\n          <button className=\"button\" onClick={handleSort}>\n            Sort\n          </button>\n          <button className=\"button\" onClick={handleReset}>\n            Reset\n          </button>\n        </div>\n      </div>\n\n      <div className=\"row\">\n        <div className=\"column\">\n          <Graph\n            id=\"myChart1\"\n            sortType=\"Selection Sort\"\n            sort={sortEn}\n            reset={reset}\n            nums={nums}\n            max={max}\n            sortFunction={SelectionSort}\n          />\n          <Graph\n            id=\"myChart2\"\n            sortType=\"Bubble Sort\"\n            sort={sortEn}\n            reset={reset}\n            nums={nums}\n            max={max}\n            sortFunction={BubbleSort}\n          />\n          <Graph\n            id=\"myChart3\"\n            sortType=\"Shell Sort\"\n            sort={sortEn}\n            reset={reset}\n            nums={nums}\n            max={max}\n            sortFunction={ShellSort}\n          />\n        </div>\n        <div className=\"column\">\n          <Graph\n            id=\"myChart4\"\n            sortType=\"Merge Sort\"\n            sort={sortEn}\n            reset={reset}\n            nums={nums}\n            max={max}\n            sortFunction={MergeSort}\n          />\n          <Graph\n            id=\"myChart5\"\n            sortType=\"Quick Sort\"\n            sort={sortEn}\n            reset={reset}\n            nums={nums}\n            max={max}\n            sortFunction={QuickSort}\n          />\n          <Graph\n            id=\"myChart6\"\n            sortType=\"Insertion Sort\"\n            sort={sortEn}\n            reset={reset}\n            nums={nums}\n            max={max}\n            sortFunction={InsertionSort}\n          />\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App.js';\n//import reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n  \n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n//reportWebVitals();\n"],"sourceRoot":""}